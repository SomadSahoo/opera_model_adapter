# MMvIB Opera Adapter

The API is available at http://localhost:9300/openapi

The project is based on TNO's Flask REST API template. For more information, see below.

## Container
No Docker container application has been created for the OPERA adapter. 


## Flask REST API Template

This is a skeleton application for a REST API. It contains a modular setup that should prevent annoying circular imports
that are sometimes an issue when scaling up Flask applications. It also contains a
generic library of code developed in other projects (under tno/shared).

The key dependencies are:

- [Flask-smorest](https://flask-smorest.readthedocs.io): A REST API framework built on top
  of [marshmallow](https://marshmallow.readthedocs.io/).

## Using the application

Before running the adapter services, make sure that the model registry and the database-Minio services are already running. Otherwise, you will encounter errors. 

The application can be run locally through two ways. The first is to run the `main` app present within the directory `..\tno\aimms_adapter\`. The second is to create a service that runs as a system service. The details of creating such a service is presented in the `MOTER_services.docx` file. FYI: This file is for the MOTER adapter services, but works the same for the OPERA adapter. 


Before running the application locally though, you are advised to create a virtual environment. Install the dependencies
using `pip install -r requirements.txt`, or `make requirements`. Then, copy the .env-template file to .env.

Either way, the API should start on http://localhost:9300. Access the autogenerated docs
through http://localhost:9300/openapi or http://localhost:9300/redoc.

The local registry endpoint is http://localhost:9200/registry. This should be kept the same for all adapters. 

The external URL for my set up, which is Windows-based OS, is http://host.docker.internal:9301. With only `localhost`, I was getting issues related to incompatibility as the orchestrator, which calls this service, runs on docker. In addition, this external URL does not cause any conflict when running the OPERA adapter as a standalone service. 


## Notable features

There is a very permissive setup of CORS, so that an arbitrary frontend can perform requests to this REST PAI.

The application contains a setup of structlog, a structured logging framework. This makes it trivial to perform more
advanced logging, and will by default output JSON logs in production and colored tab-separated logs in development.

For dependency management we use pip-tools, which is a combination of pip-compile (which generates a requirements.txt
from a requirements.in file) and pip-sync (which synchronizes your virtualenv to the exact state as specified in the
requirements.txt).

The configuration of Flask-Migrate set up to facilitate database migrations through Alembic.

There is a basic configuration of mypy (see mypy.ini) for static type checking.

## Design decisions

### Flask-smorest

Flask-smorest is but one option for REST APIs in Flask. It seems currently the most up to date option, and added bonuses
are that it is relatively lightweight, building on top of existing paradigms from Flask (such as Blueprints) and
building on top of marshmallow for schema validation.

Flask-Restless just generates REST-like API's for your database models. This is not really REST and can be quite
fragile.

Flask-RESTPlus is pretty nice and is very similar to Flask-smorest. It is heavier than Flask-smorest though, inventing
more of their own paradigms on top of Flask. It is hardly maintained though.

There is also Flask-RESTX, which is a fork of Flask-RESTPlus so is very similar. We've used it together with
flask-accepts, marshmallow, and marshmallow-dataclass for pretty nice results. However, Flask-smorest does not need any
of that because it just directly builds on top of marshmallow, so the end result is cleaner.